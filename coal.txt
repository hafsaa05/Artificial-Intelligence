--------------------------------------------------------------------------------
-- complete pl/sql reference file
-- contains all major concepts with easy examples:
-- 1. %type
-- 2. %rowtype
-- 3. implicit cursor
-- 4. implicit cursor attributes (sql%rowcount, sql%found, sql%notfound)
-- 5. explicit cursor
-- 6. explicit cursor attributes (%found, %notfound, %rowcount)
-- 7. cursor for loop
-- 8. parameterized cursor
-- 9. user-defined record type
--------------------------------------------------------------------------------

set serveroutput on;

--------------------------------------------------------------------------------
-- 1. %TYPE example (matches datatype of a column)
--------------------------------------------------------------------------------
declare
    v_emp_salary employees.salary%type;     -- inherits datatype of salary column
    v_emp_name   employees.first_name%type; -- inherits datatype of first_name
begin
    select salary, first_name
    into v_emp_salary, v_emp_name
    from employees
    where employee_id = 100;

    dbms_output.put_line('(%TYPE) name: ' || v_emp_name || ', salary: ' || v_emp_salary);
end;
/
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- 2. %ROWTYPE example (full row structure of a table)
--------------------------------------------------------------------------------
declare
    emp_rec employees%rowtype;  -- contains all columns of employees table
begin
    select *
    into emp_rec
    from employees
    where employee_id = 101;

    dbms_output.put_line('(%ROWTYPE) employee: ' ||
        emp_rec.first_name || ' ' || emp_rec.last_name ||
        ', salary: ' || emp_rec.salary);
end;
/
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- 3. Implicit cursor example (normal SELECT / UPDATE / DELETE)
--    Oracle manages the cursor automatically.
--------------------------------------------------------------------------------
declare
    v_rows number;
begin
    update employees
    set salary = salary + 100
    where department_id = 50;

    -- implicit cursor attribute
    v_rows := sql%rowcount;  -- number of rows updated

    dbms_output.put_line('(implicit cursor) rows updated = ' || v_rows);
end;
/
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- 4. Implicit cursor attributes
--    sql%rowcount, sql%found, sql%notfound, sql%isopen
--------------------------------------------------------------------------------
declare
    v_test employees.employee_id%type := 9999; -- id that doesn't exist
begin
    delete from employees
    where employee_id = v_test;

    if sql%notfound then
        dbms_output.put_line('(implicit attributes) no row deleted');
    end if;

    dbms_output.put_line('(implicit attributes) rowcount = ' || sql%rowcount);
end;
/
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- 5. Explicit cursor example
--------------------------------------------------------------------------------
declare
    cursor c_emp is
        select employee_id, first_name, salary
        from employees
        where department_id = 60;

    emp_row c_emp%rowtype;  -- record structure of cursor
begin
    open c_emp;
    loop
        fetch c_emp into emp_row;
        exit when c_emp%notfound;

        dbms_output.put_line('(explicit cursor) ' ||
            emp_row.first_name || ' -- salary: ' || emp_row.salary);
    end loop;
    close c_emp;

    dbms_output.put_line('rows fetched = ' || c_emp%rowcount);
end;
/
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- 6. Cursor FOR loop (simplest way, no open/close needed)
--------------------------------------------------------------------------------
declare
    cursor c_loop is
        select employee_id, first_name, salary
        from employees
        where salary > 5000;
begin
    for r in c_loop loop
        dbms_output.put_line('(cursor for loop) ' ||
            r.first_name || ' earns ' || r.salary);
    end loop;
end;
/
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- 7. Parameterized cursor example
--------------------------------------------------------------------------------
declare
    cursor c_dept(p_dept_id number) is
        select employee_id, first_name, salary
        from employees
        where department_id = p_dept_id;

begin
    dbms_output.put_line('department 50 employees:');
    for r in c_dept(50) loop
        dbms_output.put_line(r.first_name || ' - ' || r.salary);
    end loop;

    dbms_output.put_line('department 80 employees:');
    for r in c_dept(80) loop
        dbms_output.put_line(r.first_name || ' - ' || r.salary);
    end loop;
end;
/
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
-- 8. User-defined RECORD type (custom structure)
--------------------------------------------------------------------------------
declare
    type emp_type is record (
        id      employees.employee_id%type,
        name    employees.first_name%type,
        sal     employees.salary%type
    );

    emp emp_type;
begin
    select employee_id, first_name, salary
    into emp.id, emp.name, emp.sal
    from employees
    where employee_id = 102;

    dbms_output.put_line('(record type) ' || emp.name || ' salary = ' || emp.sal);
end;
/
--------------------------------------------------------------------------------
-- =============================================================
-- COMPLETE TRIGGERS FILE (DML + DDL)
-- Includes: Definitions, Types, Syntax, Examples, Comments
-- Copy & use for your revision and practical work
-- =============================================================


/* =============================================================
   1. WHAT IS A TRIGGER?
   -------------------------------------------------------------
   • A trigger is a stored PL/SQL program block.
   • It executes AUTOMATICALLY when a specific event occurs.
   • Events can be DML, DDL, or Database/System events.
   • NO manual execution – they fire implicitly.
   ============================================================= */


/* =============================================================
   2. TYPES OF TRIGGERS
   -------------------------------------------------------------
   A. DML Triggers (INSERT, UPDATE, DELETE)
      - Statement Level
      - Row Level (FOR EACH ROW)
      - BEFORE or AFTER
      - Can use :NEW and :OLD

   B. DDL Triggers (CREATE, ALTER, DROP)
      - ON SCHEMA
      - ON DATABASE
      - Used for auditing schema changes

   C. System / Event Triggers
      - LOGON, LOGOFF, STARTUP, SHUTDOWN

   D. INSTEAD OF Triggers (on views)

   E. Compound Triggers
   ============================================================= */


/* =============================================================
   3. GENERAL SYNTAX — DML TRIGGERS
   ============================================================= */

-- STATEMENT LEVEL DML TRIGGER
CREATE OR REPLACE TRIGGER trigger_name
BEFORE | AFTER
INSERT OR UPDATE OR DELETE
ON table_name
WHEN (condition)   -- optional
DECLARE
   -- variables here
BEGIN
   -- statements to execute
END;
/

-- ROW LEVEL DML TRIGGER (uses :NEW and :OLD)
CREATE OR REPLACE TRIGGER trigger_name
BEFORE | AFTER
INSERT OR UPDATE OR DELETE
ON table_name
FOR EACH ROW
WHEN (condition)   -- optional
DECLARE
   -- declarations
BEGIN
   -- row level logic here
END;
/


/* =============================================================
   4. GENERAL SYNTAX — DDL TRIGGERS
   ============================================================= */

-- DDL TRIGGER ON SCHEMA
CREATE OR REPLACE TRIGGER trigger_name
AFTER | BEFORE DDL
ON SCHEMA
BEGIN
   -- use ora_sysevent, ora_dict_obj_name, ora_dict_obj_type
END;
/

-- DDL TRIGGER ON DATABASE
CREATE OR REPLACE TRIGGER trigger_name
AFTER | BEFORE DDL
ON DATABASE
BEGIN
   -- executes for all users in the database
END;
/


/* =============================================================
   5. PSEUDO RECORDS (:NEW and :OLD)
   -------------------------------------------------------------
   :NEW.column → new value during INSERT/UPDATE
   :OLD.column → old value during UPDATE/DELETE
   ============================================================= */


/* =============================================================
   6. DML TRIGGER EXAMPLES
   ============================================================= */

-- EXAMPLE 1: BEFORE INSERT TRIGGER
CREATE OR REPLACE TRIGGER bi_superheroes
BEFORE INSERT ON superheroes
FOR EACH ROW
DECLARE
   v_user VARCHAR2(20);
BEGIN
   SELECT USER INTO v_user FROM dual;
   DBMS_OUTPUT.PUT_LINE('Row inserted by: ' || v_user);
END;
/


-- EXAMPLE 2: BEFORE UPDATE TRIGGER
CREATE OR REPLACE TRIGGER bu_superheroes
BEFORE UPDATE ON superheroes
FOR EACH ROW
DECLARE
   v_user VARCHAR2(20);
BEGIN
   SELECT USER INTO v_user FROM dual;
   DBMS_OUTPUT.PUT_LINE('Row updated by: ' || v_user);
END;
/


-- EXAMPLE 3: BEFORE DELETE TRIGGER
CREATE OR REPLACE TRIGGER bd_superheroes
BEFORE DELETE ON superheroes
FOR EACH ROW
DECLARE
   v_user VARCHAR2(20);
BEGIN
   SELECT USER INTO v_user FROM dual;
   DBMS_OUTPUT.PUT_LINE('Row deleted by: ' || v_user);
END;
/


-- EXAMPLE 4: ONE TRIGGER FOR INSERT, UPDATE, DELETE
CREATE OR REPLACE TRIGGER tri_superheroes
BEFORE INSERT OR UPDATE OR DELETE ON superheroes
FOR EACH ROW
DECLARE
   v_user VARCHAR2(20);
BEGIN
   SELECT USER INTO v_user FROM dual;

   IF INSERTING THEN
      DBMS_OUTPUT.PUT_LINE('Insert performed by ' || v_user);

   ELSIF UPDATING THEN
      DBMS_OUTPUT.PUT_LINE('Update performed by ' || v_user);

   ELSIF DELETING THEN
      DBMS_OUTPUT.PUT_LINE('Delete performed by ' || v_user);
   END IF;
END;
/


/* =============================================================
   7. AUDITING TRIGGER EXAMPLE
   ============================================================= */

-- AUDIT TABLE
CREATE TABLE sh_audit(
   new_name VARCHAR2(30),
   old_name VARCHAR2(30),
   username VARCHAR2(30),
   action_date VARCHAR2(30),
   operation VARCHAR2(20)
);

-- AUDIT TRIGGER
CREATE OR REPLACE TRIGGER sh_audit_tr
BEFORE INSERT OR UPDATE OR DELETE ON superheroes
FOR EACH ROW
DECLARE
   v_user VARCHAR2(30);
   v_date VARCHAR2(30);
BEGIN
   SELECT USER, TO_CHAR(SYSDATE, 'DD-MON-YYYY HH24:MI:SS')
   INTO v_user, v_date
   FROM dual;

   IF INSERTING THEN
      INSERT INTO sh_audit VALUES(:NEW.sh_name, NULL, v_user, v_date, 'INSERT');

   ELSIF UPDATING THEN
      INSERT INTO sh_audit VALUES(:NEW.sh_name, :OLD.sh_name, v_user, v_date, 'UPDATE');

   ELSIF DELETING THEN
      INSERT INTO sh_audit VALUES(NULL, :OLD.sh_name, v_user, v_date, 'DELETE');
   END IF;
END;
/


/* =============================================================
   8. BACKUP TABLE SYNCHRONIZATION TRIGGER
   ============================================================= */

-- BACKUP TABLE CREATION
CREATE TABLE superheroes_backup AS
SELECT * FROM superheroes WHERE 1 = 2;

-- BACKUP TRIGGER
CREATE OR REPLACE TRIGGER sh_backup
BEFORE INSERT OR UPDATE OR DELETE ON superheroes
FOR EACH ROW
BEGIN
   IF INSERTING THEN
      INSERT INTO superheroes_backup VALUES(:NEW.sh_name);

   ELSIF UPDATING THEN
      UPDATE superheroes_backup
      SET sh_name = :NEW.sh_name
      WHERE sh_name = :OLD.sh_name;

   ELSIF DELETING THEN
      DELETE FROM superheroes_backup
      WHERE sh_name = :OLD.sh_name;
   END IF;
END;
/


/* =============================================================
   9. DDL TRIGGER EXAMPLES
   ============================================================= */

-- SCHEMA-LEVEL DDL AUDIT TABLE
CREATE TABLE schema_audit(
   ddl_date DATE,
   ddl_user VARCHAR2(30),
   object_type VARCHAR2(30),
   object_name VARCHAR2(30),
   ddl_operation VARCHAR2(30)
);

-- SCHEMA-LEVEL DDL TRIGGER
CREATE OR REPLACE TRIGGER schema_audit_tr
AFTER DDL ON SCHEMA
BEGIN
   INSERT INTO schema_audit
   VALUES(
      SYSDATE,
      sys_context('USERENV','CURRENT_USER'),
      ora_dict_obj_type,
      ora_dict_obj_name,
      ora_sysevent
   );
END;
/


-- DATABASE-LEVEL DDL TRIGGER
CREATE OR REPLACE TRIGGER db_ddl_audit_tr
AFTER DDL ON DATABASE
BEGIN
   INSERT INTO schema_audit
   VALUES(
      SYSDATE,
      sys_context('USERENV','CURRENT_USER'),
      ora_dict_obj_type,
      ora_dict_obj_name,
      ora_sysevent
   );
END;
/


/* =============================================================
   END OF COMPLETE TRIGGER FILE
   ============================================================= */
-- ===============================================================
-- FILE: TCL_Transactions_Lab.sql
-- PURPOSE: Demonstrate all concepts of Transaction Control Language (TCL)
-- ===============================================================

-- ===============================================================
-- 1. INTRODUCTION TO DATABASE TRANSACTIONS
-- A transaction is a sequence of one or more SQL statements that 
-- perform a single logical unit of work.
-- All operations succeed or fail together to maintain data integrity.
-- ===============================================================

-- Example Scenario: Fund Transfer
-- Debit from Account A and credit to Account B. 
-- If either action fails, rollback the entire transaction.

-- ===============================================================
-- 2. TRANSACTION CONTROL COMMANDS (TCL)
-- COMMIT     -> Makes changes permanent
-- ROLLBACK   -> Reverts changes to the start of transaction or SAVEPOINT
-- SAVEPOINT  -> Marks a point in transaction for partial rollback
-- SET TRANSACTION -> Sets properties for the transaction
-- AUTOCOMMIT -> Automatically commits every DML statement
-- ===============================================================

-- ===============================================================
-- 3. EXPLICIT TRANSACTION CONTROL
-- Users manually control when to commit or rollback.
-- ===============================================================

-- Create a sample table for demonstration
CREATE TABLE worker (
    worker_id NUMBER PRIMARY KEY,
    worker_name VARCHAR2(50),
    salary NUMBER
);

-- Insert initial record (needs commit)
INSERT INTO worker (worker_id, worker_name, salary) VALUES (1, 'Sohail', 5000);

-- Start a transaction
SET TRANSACTION NAME 'worker_salary_update';

-- Update worker's salary (not yet committed)
UPDATE worker SET salary = 6000 WHERE worker_id = 1;

-- Create a savepoint
SAVEPOINT sp1;

-- Update salary again
UPDATE worker SET salary = 7000 WHERE worker_id = 1;

-- Rollback to previous savepoint
ROLLBACK TO SAVEPOINT sp1;  -- Salary goes back to 6000

-- Commit the transaction
COMMIT;

-- ===============================================================
-- 4. IMPLICIT TRANSACTION CONTROL
-- Oracle auto commits or rolls back in certain cases:
-- 1. DDL or DCL statements -> automatic COMMIT
-- 2. Abnormal exit or system failure -> automatic ROLLBACK
-- ===============================================================

-- Example: DDL auto-commits
CREATE TABLE sample_auto_commit (
    id NUMBER,
    name VARCHAR2(20)
);
-- The above CREATE TABLE implicitly commits any open transaction

-- ===============================================================
-- 5. USING AUTOCOMMIT
-- Enable AUTOCOMMIT so each DML statement is automatically committed
-- ===============================================================

-- Enable AUTOCOMMIT
SET AUTOCOMMIT ON;

-- Insert a record automatically committed
INSERT INTO worker (worker_id, worker_name, salary) VALUES (2, 'Erum', 5500);

-- Disable AUTOCOMMIT for manual control
SET AUTOCOMMIT OFF;

-- ===============================================================
-- 6. TRANSACTION FLOW EXAMPLE
-- Update salaries with savepoints and rollbacks
-- ===============================================================

-- Start transaction
SET TRANSACTION NAME 'sal_update';

-- Update Banda's salary
UPDATE employees SET salary = 7000 WHERE last_name = 'Banda';

-- Create savepoint
SAVEPOINT after_banda_sal;

-- Update Greene's salary
UPDATE employees SET salary = 12000 WHERE last_name = 'Greene';

-- Create another savepoint
SAVEPOINT after_greene_sal;

-- Rollback Greene's update only
ROLLBACK TO SAVEPOINT after_banda_sal;

-- Update Greene's salary again
UPDATE employees SET salary = 11000 WHERE last_name = 'Greene';

-- Rollback the entire transaction
ROLLBACK;

-- Start a new transaction
SET TRANSACTION NAME 'sal_update2';
UPDATE employees SET salary = 7050 WHERE last_name = 'Banda';
UPDATE employees SET salary = 10950 WHERE last_name = 'Greene';
-- Commit final changes
COMMIT;

-- ===============================================================
-- 7. CUSTOMER AND ORDER TRANSACTION SCENARIO
-- ===============================================================

-- Create Customer and Orders Tables
CREATE TABLE customer (
    cust_id NUMBER PRIMARY KEY,
    cust_name VARCHAR2(50),
    balance NUMBER
);

CREATE TABLE orders (
    order_id NUMBER PRIMARY KEY,
    cust_id NUMBER,
    order_amount NUMBER
);

-- Start transaction
SET TRANSACTION NAME 'customer_order_transaction';

-- Step 1: Insert customer and set savepoint
INSERT INTO customer VALUES (1, 'Ali', 5000);
SAVEPOINT customer_added;

-- Step 2: Insert order and update balance
INSERT INTO orders VALUES (101, 1, 3000);
UPDATE customer SET balance = balance - 3000 WHERE cust_id = 1;
SAVEPOINT order_added;

-- Step 3: Commit or rollback depending on balance
-- Example condition (pseudo-code):
-- If balance sufficient, COMMIT; else ROLLBACK TO SAVEPOINT customer_added;

-- ===============================================================
-- 8. SUMMARY OF KEY POINTS
-- 1. Transaction = logical unit of work
-- 2. COMMIT = save changes permanently
-- 3. ROLLBACK = undo changes
-- 4. SAVEPOINT = partial rollback point
-- 5. DML statements require explicit commit
-- 6. DDL/DCL statements auto-commit
-- 7. AUTOCOMMIT commits every statement automatically
-- 8. Savepoints help manage complex transactions
-- ===============================================================

-- END OF TCL TRANSACTIONS LAB
/********************************************
 *  MONGODB COMPLETE REFERENCE FILE
 ********************************************/

/******************************************************
 *  1. Overview of MongoDB
 ******************************************************/
// MongoDB is a NoSQL, document-oriented database.
// - Stores data as JSON-like documents (BSON internally)
// - Schema-less, so documents in same collection can differ
// - High performance, high availability, and scalability
// - Cross-platform, written in C++
// Use cases: e-commerce, analytics, content management, IoT

/******************************************************
 *  2. Key Concepts & Terminology
 ******************************************************/
// Database: Container of collections
// Collection: Group of documents (like a table in RDBMS)
// Document: JSON-like object containing key-value pairs
// Field: Key-value pair inside a document
// ObjectId: Default unique identifier (_id) for documents
// Dynamic schema: Not all documents require same fields
// Index: Speeds up queries (similar to RDBMS index)

/******************************************************
 *  3. Installing & Connecting
 ******************************************************/
// Use MongoDB Atlas (cloud) or local server
// Use Mongo Shell (mongosh) or GUI MongoDB Compass
// Connect to a database:
//   mongosh "mongodb://localhost:27017"
// Create / switch DB:
//   use myDatabase

/******************************************************
 *  4. Creating Database & Collections
 ******************************************************/
// Create database (will exist after first insert)
use bookstoreDB;

// Create collection explicitly
db.createCollection("books");

// Create collection by inserting document (auto-create)
db.books.insertOne({
    title: "A Tale of Two Cities",
    author: "Charles Dickens",
    genre: ["historical", "fiction"]
});

/******************************************************
 *  5. Inserting Documents
 ******************************************************/
// Single document
db.books.insertOne({
    title: "Harry Potter",
    author: "J.K. Rowling",
    genre: ["fantasy", "children"],
    price: 500
});

// Multiple documents
db.books.insertMany([
    { title: "Alchemist", author: "Paulo Coelho", genre: ["fiction"], price: 300 },
    { title: "1984", author: "George Orwell", genre: ["dystopia"], price: 400 }
]);

/******************************************************
 *  6. Querying Documents (find)
 ******************************************************/
// Find all documents
db.books.find();

// Find with condition
db.books.find({price: {$gt: 350}}); // price greater than 350

// Find with AND
db.books.find({$and: [{price: {$gt: 200}}, {price: {$lt: 500}}]});

// Find with OR
db.books.find({$or: [{price: {$lt: 200}}, {genre: "dystopia"}]});

// Projection (return only specific fields)
db.books.find({}, {title: 1, author: 1, _id: 0});

/******************************************************
 *  7. Updating Documents
 ******************************************************/
// Update one document
db.books.updateOne(
    {title: "1984"},
    {$set: {price: 450}}
);

// Update multiple documents
db.books.updateMany(
    {price: {$lt: 400}},
    {$inc: {price: 50}} // Increase price by 50
);

/******************************************************
 *  8. Deleting Documents
 ******************************************************/
// Delete one document
db.books.deleteOne({title: "Alchemist"});

// Delete many documents
db.books.deleteMany({price: {$lt: 400}});

/******************************************************
 *  9. Dropping Collections & Databases
 ******************************************************/
// Drop collection
db.books.drop();

// Drop database
use bookstoreDB;
db.dropDatabase();

/******************************************************
 *  10. Sorting, Limiting, Skipping
 ******************************************************/
// Sort ascending
db.books.find().sort({price: 1});

// Sort descending
db.books.find().sort({price: -1});

// Limit number of documents
db.books.find().limit(3);

// Skip documents (for pagination)
db.books.find().skip(2).limit(3);

/******************************************************
 *  11. Aggregation
 ******************************************************/
// Group by genre and count
db.books.aggregate([
    {$group: {_id: "$genre", totalBooks: {$sum: 1}}}
]);

// Average price per genre
db.books.aggregate([
    {$group: {_id: "$genre", avgPrice: {$avg: "$price"}}}
]);

// Sorting aggregated results
db.books.aggregate([
    {$group: {_id: "$genre", totalBooks: {$sum: 1}}},
    {$sort: {totalBooks: -1}}
]);

/******************************************************
 *  12. Counting Documents
 ******************************************************/
db.books.countDocuments(); // total count
db.books.countDocuments({price: {$gt: 300}}); // conditional count

/******************************************************
 *  13. Text Search & Regex
 ******************************************************/
// Create text index
db.books.createIndex({title: "text", author: "text"});

// Search text
db.books.find({$text: {$search: "Harry"}});

// Regex search (partial match)
db.books.find({title: {$regex: "^The", $options: "i"}}); // starts with 'The', case-insensitive

/******************************************************
 *  14. Updating with Increment / Decrement
 ******************************************************/
db.books.updateMany({}, {$inc: {price: 10}}); // Increase price by 10
db.books.updateOne({title: "1984"}, {$inc: {price: -20}}); // Decrease price

/******************************************************
 *  15. Using findOneAndUpdate / findOneAndDelete
 ******************************************************/
// Update and return new document
db.books.findOneAndUpdate(
    {title: "Harry Potter"},
    {$set: {price: 550}},
    {returnDocument: "after"}
);

// Delete and return deleted document
db.books.findOneAndDelete({title: "1984"});

/******************************************************
 *  16. Advanced Queries Examples
 ******************************************************/
// Employees collection example
db.employee.insertMany([
    {name: "Ali", salary: 5000, department: "IT", bonus: 0, lastActive: ISODate("2024-10-05")},
    {name: "Ahmed", salary: 8000, department: "HR", bonus: 100, lastActive: ISODate("2024-10-01")},
]);

// Find employees with no bonus
db.employee.find({bonus: 0});

// Highest-paid employee in HR
db.employee.find({department: "HR"}).sort({salary: -1}).limit(1);

// Increase salary 10% for last 30 days active
db.employee.updateMany(
    {lastActive: {$gte: new Date(new Date() - 30*24*60*60*1000)}},
    {$mul: {salary: 1.1}}
);

// Aggregate total spending per customer
db.orders.aggregate([
    {$group: {_id: "$customerName", totalSpent: {$sum: "$totalAmount"}}}
]);

// Customers with more than 5 orders
db.orders.aggregate([
    {$group: {_id: "$customerId", orderCount: {$sum: 1}}},
    {$match: {orderCount: {$gt: 5}}}
]);

// Most frequently purchased product
db.orders.aggregate([
    {$unwind: "$items"},
    {$group: {_id: "$items.product", count: {$sum: 1}}},
    {$sort: {count: -1}},
    {$limit: 1}
]);

// Total revenue year-wise
db.orders.aggregate([
    {$group: {_id: {$year: "$orderDate"}, totalRevenue: {$sum: "$totalAmount"}}}
]);

/******************************************************
 *  17. Tips for MongoDB in Exams
 ******************************************************/
// 1. Always know if collection exists or will be auto-created.
// 2. Use find(), insertOne(), insertMany() for basics.
// 3. Use aggregate() for group / count / sum / avg queries.
// 4. Use update operators ($set, $inc, $mul) for updates.
// 5. Regex & text search are common for pattern matching.
// 6. Sort + limit + skip often used for top-N queries.
// 7. Always check dates using ISODate() format.

/*******************************************************
 * PAST PAPER COMPLETE REFERENCE FILE
 *******************************************************/

/*******************************************************
 * 1. SQL QUERIES (LLO#: 3)
 *******************************************************/
/* Concepts:
   - SELECT: fetch data
   - WHERE: filter data
   - Aggregate Functions: AVG, MIN, MAX, COUNT, SUM
   - GROUP BY: group rows by column
   - HAVING: filter after grouping
   - Subqueries: nested queries
   - Joins: combine tables
*/

/* Example 1: Employees earning more than average salary of employees hired same year */
SELECT emp_name, salary, hire_date
FROM employees e1
WHERE salary > (
    SELECT AVG(salary)
    FROM employees e2
    WHERE EXTRACT(YEAR FROM e2.hire_date) = EXTRACT(YEAR FROM e1.hire_date)
);

/* Example 2: Employees with no previous job and salary < minimum salary of employees with job history */
SELECT emp_name, job, salary
FROM employees
WHERE prev_job IS NULL
AND salary < (
    SELECT MIN(salary)
    FROM employees
    WHERE prev_job IS NOT NULL
);

/* Example 3: Employees whose commission > avg commission of same job title */
SELECT emp_name, job, salary, commission,
       (SELECT AVG(commission) FROM employees e2 WHERE e2.job = e1.job) AS job_avg_commission
FROM employees e1
WHERE commission > (
    SELECT AVG(commission)
    FROM employees e2
    WHERE e2.job = e1.job
);

/* Example 4: Employees hired in the year with max hires per department */
WITH yearly_hires AS (
    SELECT EXTRACT(YEAR FROM hire_date) AS hire_year, dept_id, COUNT(*) AS total_hires
    FROM employees
    GROUP BY EXTRACT(YEAR FROM hire_date), dept_id
),
max_hires AS (
    SELECT dept_id, MAX(total_hires) AS max_total
    FROM yearly_hires
    GROUP BY dept_id
)
SELECT e.emp_name, e.hire_date, d.dept_name, y.total_hires
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
JOIN yearly_hires y ON y.hire_year = EXTRACT(YEAR FROM e.hire_date) AND y.dept_id = e.dept_id
JOIN max_hires m ON m.dept_id = e.dept_id AND m.max_total = y.total_hires;

/* Example 5: Departments with more than 3 employees with salary > 5000 */
SELECT d.dept_name, COUNT(*) AS emp_count
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 5000
GROUP BY d.dept_name
HAVING COUNT(*) > 3;

/*******************************************************
 * 2. PL/SQL TRIGGERS & TRANSACTIONS (LLO#: 4)
 *******************************************************/
/* Concepts:
   - Triggers: automatically executed before/after INSERT, UPDATE, DELETE
   - Transactions: atomic operations using COMMIT / ROLLBACK
   - Audit fields: track CREATED_BY, UPDATED_BY, LAST_UPDATED
   - Exception handling: raise errors using RAISE_APPLICATION_ERROR
*/

/* Trigger Example: Prevent negative values and maintain audit */
CREATE OR REPLACE TRIGGER prevent_negative_values
BEFORE INSERT OR UPDATE ON products
FOR EACH ROW
DECLARE
    old_stock NUMBER;
BEGIN
    -- Prevent negative price or stock
    IF :NEW.price <= 0 OR :NEW.stock_quantity <= 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Product price or quantity cannot be negative or zero');
    END IF;

    -- Check stock reduction > 50%
    IF UPDATING THEN
        SELECT stock_quantity INTO old_stock FROM products WHERE product_id = :OLD.product_id;
        IF old_stock > 0 AND :NEW.stock_quantity < (old_stock/2) THEN
            RAISE_APPLICATION_ERROR(-20002, 'Stock reduction exceeds allowed limit (50%)');
        END IF;
    END IF;

    -- Warn if stock < 5
    IF :NEW.stock_quantity < 5 THEN
        RAISE_APPLICATION_ERROR(-20003, 'The product is going out of stock');
    END IF;

    -- Prevent manual SUBTOTAL modification
    IF :NEW.subtotal IS NOT NULL AND (:NEW.subtotal != :NEW.price * :NEW.stock_quantity) THEN
        RAISE_APPLICATION_ERROR(-20004, 'Automatically calculated field');
    END IF;

    -- Automatically calculate subtotal
    :NEW.subtotal := :NEW.price * :NEW.stock_quantity;

    -- Audit fields
    IF INSERTING THEN
        :NEW.created_by := USER;
    ELSIF UPDATING THEN
        :NEW.updated_by := USER;
    END IF;
    :NEW.last_updated := SYSDATE;
END;
/

-- Transaction Example: Place order atomically
DECLARE
    stock_left NUMBER;
BEGIN
    -- Check stock
    SELECT med_stock INTO stock_left FROM medicine WHERE med_id = 101;
    IF stock_left < 5 THEN
        RAISE_APPLICATION_ERROR(-20010, 'Not enough stock');
    END IF;

    -- Insert order
    INSERT INTO orders(order_id, cust_id) VALUES (201, 1);

    -- Insert order item and update stock
    INSERT INTO order_item(order_id, med_id, qty) VALUES (201, 101, 5);
    UPDATE medicine SET med_stock = med_stock - 5 WHERE med_id = 101;

    -- Insert log
    INSERT INTO order_log(log_id, order_id, message) VALUES (301, 201, 'Order placed successfully');

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

/*******************************************************
 * 3. PL/SQL OBJECT TYPES: ORDER BILLING SYSTEM (LLO#: 4)
 *******************************************************/
/* Concepts:
   - Object types: encapsulate data & methods
   - Member function: perform operations on object
   - Object table: table of object types
*/

/* Object Type: ORDER_ITEM */
CREATE OR REPLACE TYPE ORDER_ITEM AS OBJECT (
    item_name VARCHAR2(50),
    quantity NUMBER,
    price NUMBER,
    MEMBER FUNCTION total_cost RETURN NUMBER
);
/

CREATE OR REPLACE TYPE BODY ORDER_ITEM AS
    MEMBER FUNCTION total_cost RETURN NUMBER IS
        cost NUMBER;
    BEGIN
        cost := quantity * price;
        IF quantity > 5 THEN
            cost := cost * 0.95; -- 5% discount
        END IF;
        RETURN cost;
    END;
END;
/

/* Object Type: ORDER_BILL */
CREATE OR REPLACE TYPE ORDER_BILL AS OBJECT (
    items ORDER_ITEM_TABLE, -- nested table of ORDER_ITEM
    MEMBER PROCEDURE print_bill
);
/

CREATE OR REPLACE TYPE BODY ORDER_BILL AS
    MEMBER PROCEDURE print_bill IS
        max_cost NUMBER := 0;
        item_cost NUMBER;
    BEGIN
        FOR i IN 1..items.COUNT LOOP
            item_cost := items(i).total_cost;
            DBMS_OUTPUT.PUT_LINE('Item: ' || items(i).item_name || ', Cost: ' || item_cost);
            IF item_cost > max_cost THEN
                max_cost := item_cost;
            END IF;
        END LOOP;
        DBMS_OUTPUT.PUT_LINE('Highest bill amount: ' || max_cost);
    END;
END;
/

/*******************************************************
 * 4. MONGODB QUERIES (LLO#: 3)
 *******************************************************/
/* Concepts:
   - NoSQL, document-oriented
   - Collections = tables, Documents = rows
   - CRUD operations: insert, find, update, delete
   - Aggregation: group, sum, avg, unwind
   - Operators: $gt, $lt, $and, $or, $regex
*/

// Insert Employee document
db.employee.insertOne({
    "department": "IT",
    "salary": 75000,
    "IT": "T1",
    "lastActive": ISODate("2024-10-05"),
    "bonus": 0
});

// Insert Orders document
db.orders.insertOne({
    "customerName": "Ali Khan",
    "email": "ali@example.com",
    "orderDate": ISODate("2024-03-11"),
    "totalAmount": 15000,
    "items": [
        {"product": "Laptop", "price": 80000, "qty": 1},
        {"product": "Mouse", "price": 2000, "qty": 2}
    ]
});

// Queries:

// Employees with no bonus
db.employee.find({bonus: 0});

// Highest-paid employee in HR
db.employee.find({department: "HR"}).sort({salary: -1}).limit(1);

// Increase salary 10% for last 30 days active
db.employee.updateMany(
    {lastActive: {$gte: new Date(new Date() - 30*24*60*60*1000)}},
    {$mul: {salary: 1.1}}
);

// Total spending per customer
db.orders.aggregate([
    {$group: {_id: "$customerName", totalSpent: {$sum: "$totalAmount"}}}
]);

// Customers with more than 5 orders
db.orders.aggregate([
    {$group: {_id: "$customerId", orderCount: {$sum: 1}}},
    {$match: {orderCount: {$gt: 5}}}
]);

// Orders where any item price > 50,000
db.orders.find({"items.price": {$gt: 50000}});

// Most frequently purchased product
db.orders.aggregate([
    {$unwind: "$items"},
    {$group: {_id: "$items.product", count: {$sum: 1}}},
    {$sort: {count: -1}},
    {$limit: 1}
]);

// Total revenue year-wise
db.orders.aggregate([
    {$group: {_id: {$year: "$orderDate"}, totalRevenue: {$sum: "$totalAmount"}}}
]);

/*******************************************************
 * 5. EXAM TIPS
 *******************************************************/
/*
- SQL: Always check conditions with subqueries & aggregates.
- PL/SQL: Use triggers for validation, transactions for atomicity.
- Object Types: Remember member functions and procedures.
- MongoDB: Know CRUD, aggregation, regex, and update operators.
- Predicting answers: Write what is asked explicitly; for "show X", use SELECT/find with proper fields.
- Focus on examples given in lab manual; exams often use similar scenarios.
*/
